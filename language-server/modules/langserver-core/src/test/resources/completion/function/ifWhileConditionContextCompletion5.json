{
  "position": {
    "line": 4,
    "character": 12
  },
  "source": "function/source/ifWhileConditionContextCompletion5.bal",
  "items": [
    {
      "label": "RecordName",
      "kind": "Class",
      "detail": "Record",
      "insertText": "RecordName",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "remove(function (any) returns (boolean) func)(int|error)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nRemove data from the table.\n  \n  \n---    \n**Parameters**  \n- _func_  \n    The function pointer for delete crieteria  \n  \n  \n**Return**  \nint|error"
        }
      },
      "insertText": "remove(${1:func})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "channel",
      "kind": "Keyword",
      "detail": "Channel",
      "insertText": "channel",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "isSingleton()(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nCheck whether the XML sequence contains only a single element.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nboolean"
        }
      },
      "insertText": "isSingleton()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "values()(any[])",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns an array of values contained in the specified map.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nany[]"
        }
      },
      "insertText": "values()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "isEmpty()(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nCheck whether the XML sequence is empty.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nboolean"
        }
      },
      "insertText": "isEmpty()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "xml",
      "kind": "Keyword",
      "detail": "Xml",
      "insertText": "xml",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "queryTableWithJoinClause(string sqlQuery, table fromTable, table joinTable, any parameters, any retType)(table\u003c$anonType$builtin$8\u003e)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nExecute the given sql query to fetch the records and return as a new in memory table.\n  \n  \n---    \n**Parameters**  \n- _sqlQuery_  \n    The query to execute  \n  \n- _fromTable_  \n    The table on which the query is executed  \n  \n- _joinTable_  \n    The table which is joined with \u0027fromTable\u0027  \n  \n- _parameters_  \n    liternal parameters to be passed to prepared statement \u0027sqlQuery\u0027  \n  \n- _retType_  \n    return type of the resultant table instance  \n  \n  \n**Return**  \ntable\u003c$anonType$builtin$8\u003e"
        }
      },
      "insertText": "queryTableWithJoinClause(${1:sqlQuery}, ${2:fromTable}, ${3:joinTable}, ${4:parameters}, ${5:retType})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "TableConfig",
      "kind": "Class",
      "detail": "Record",
      "documentation": {
        "left": "TableConfig represents properties used during table initialization.\n"
      },
      "insertText": "TableConfig",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "publish(any data)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nPublishes data to the stream.\n  \n  \n---    \n**Parameters**  \n- _data_  \n    Data to be published to the stream  \n"
        }
      },
      "insertText": "publish(${1:data});",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "toUpper()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns a string with all the characters converted to uppercase.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nstring"
        }
      },
      "insertText": "toUpper()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "hasSuffix(string suffix)(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns a Boolean value indicating whether the string ends with specified suffix.\n  \n  \n---    \n**Parameters**  \n- _suffix_  \n    The suffix to be compared  \n  \n  \n**Return**  \nboolean"
        }
      },
      "insertText": "hasSuffix(${1:suffix})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "byte",
      "kind": "Keyword",
      "detail": "Byte",
      "insertText": "byte",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "indexOf(string substring)(int)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns the first index of the first occurence of the substring within the specified string.\n  \n  \n---    \n**Parameters**  \n- _substring_  \n    The substring to search for  \n  \n  \n**Return**  \nint"
        }
      },
      "insertText": "indexOf(${1:substring})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "substring(int startIndex, int endIndex)(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns a new string that is the substring of the specified string.\n  \n  \n---    \n**Parameters**  \n- _startIndex_  \n    The starting index  \n  \n- _endIndex_  \n    The ending index  \n  \n  \n**Return**  \nstring"
        }
      },
      "insertText": "substring(${1:startIndex}, ${2:endIndex})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "hasKey(string key)(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nCheck whether specific key exists from the given map.\n  \n  \n---    \n**Parameters**  \n- _key_  \n    The key to be find existence  \n  \n  \n**Return**  \nboolean"
        }
      },
      "insertText": "hasKey(${1:key})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "remove(string key)(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nRemoves the specified element from the map.\n  \n  \n---    \n**Parameters**  \n- _key_  \n    The key to be removed  \n  \n  \n**Return**  \nboolean"
        }
      },
      "insertText": "remove(${1:key})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "replaceAll(string regex, string replaceWith)(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReplaces each substring of the string that matches the given regular expression with the given replacement.\n  \n  \n---    \n**Parameters**  \n- _regex_  \n    The regular expression to search for  \n  \n- _replaceWith_  \n    The replacement string  \n  \n  \n**Return**  \nstring"
        }
      },
      "insertText": "replaceAll(${1:regex}, ${2:replaceWith})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "queryTableWithoutJoinClause(string sqlQuery, table fromTable, any parameters, any retType)(table\u003c$anonType$builtin$10\u003e)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nExecute the given sql query to fetch the records and return as a new in memory table.\n  \n  \n---    \n**Parameters**  \n- _sqlQuery_  \n    The query to execute  \n  \n- _fromTable_  \n    The table on which the query is executed  \n  \n- _parameters_  \n    literal parameters to be passed to prepared statement \u0027sqlQuery\u0027  \n  \n- _retType_  \n    return type of the resultant table instance  \n  \n  \n**Return**  \ntable\u003c$anonType$builtin$10\u003e"
        }
      },
      "insertText": "queryTableWithoutJoinClause(${1:sqlQuery}, ${2:fromTable}, ${3:parameters}, ${4:retType})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "startForever(string streamQuery, any inStreamRefs, any inTableRefs, any outStreamRefs, any outTableRefs, any funcPointers)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nCreates the forever runtime.\n  \n  \n---    \n**Parameters**  \n- _streamQuery_  \n    The siddhi query by which the siddhi app runtime is created  \n  \n- _inStreamRefs_  \n    References of the input streams in the forever  \n  \n- _inTableRefs_  \n    References of the input tables in the forever  \n  \n- _outStreamRefs_  \n    References of the output streams in the forever  \n  \n- _outTableRefs_  \n    References of the output tables in the forever  \n  \n- _funcPointers_  \n    References of the functions to invoke as the streaming action  \n"
        }
      },
      "insertText": "startForever(${1:streamQuery}, ${2:inStreamRefs}, ${3:inTableRefs}, ${4:outStreamRefs}, ${5:outTableRefs}, ${6:funcPointers});",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "equalsIgnoreCase(string anotherString)(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nCompares two strings, ignoring the case of the strings.\n  \n  \n---    \n**Parameters**  \n- _anotherString_  \n    The string to be compared  \n  \n  \n**Return**  \nboolean"
        }
      },
      "insertText": "equalsIgnoreCase(${1:anotherString})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "stream",
      "kind": "Keyword",
      "detail": "Stream",
      "insertText": "stream",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "AbstractListener",
      "kind": "Class",
      "detail": "Object",
      "insertText": "AbstractListener",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "replaceFirst(string regex, string replaceWith)(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReplaces the first instance of the replacePattern with the replaceWith string and returns the result.\n  \n  \n---    \n**Parameters**  \n- _regex_  \n    The pattern to search for  \n  \n- _replaceWith_  \n    The replacement string  \n  \n  \n**Return**  \nstring"
        }
      },
      "insertText": "replaceFirst(${1:regex}, ${2:replaceWith})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "map",
      "kind": "Keyword",
      "detail": "Map",
      "insertText": "map",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "table",
      "kind": "Keyword",
      "detail": "Table",
      "insertText": "table",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "select(string qname)(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nGet all the items that are of element type, and matches the given qualified name, in an XML sequence.\n  \n  \n---    \n**Parameters**  \n- _qname_  \n    Qualified name of the element  \n  \n  \n**Return**  \nxml"
        }
      },
      "insertText": "select(${1:qname})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "anydata",
      "kind": "Keyword",
      "detail": "Anydata",
      "insertText": "anydata",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "split(string regex)(string[])",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nSplits the string with the given regular expression to produce a string array.\n  \n  \n---    \n**Parameters**  \n- _regex_  \n    The regex to split the string  \n  \n  \n**Return**  \nstring[]"
        }
      },
      "insertText": "split(${1:regex})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "replace(string regex, string replaceWith)(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReplaces all instances of the replacePattern string with the replaceWith string and returns the result.\n  \n  \n---    \n**Parameters**  \n- _regex_  \n    The pattern to search for  \n  \n- _replaceWith_  \n    The replacement string  \n  \n  \n**Return**  \nstring"
        }
      },
      "insertText": "replace(${1:regex}, ${2:replaceWith})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "getNext()(any)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nRetrives the current row and return a record with the data in the columns.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nany"
        }
      },
      "insertText": "getNext()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "clear()",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nClear the items from given map.  \n  \n---    \n**Parameters**  \n"
        }
      },
      "insertText": "clear();",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "hashCode()(int)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns a hash code for this string.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nint"
        }
      },
      "insertText": "hashCode()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "future",
      "kind": "Keyword",
      "detail": "Future",
      "insertText": "future",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "close()",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReleases the database connection. If the table data is fully iterated, it will be automatically closed. This explicit\nclose is required only if it is not fully iterated.  \n  \n---    \n**Parameters**  \n"
        }
      },
      "insertText": "close();",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "copy()(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nMake a deep copy of an XML.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nxml"
        }
      },
      "insertText": "copy()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "setAttributes(map attributes)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nSets the attributes to the provided attributes map.\n  \n  \n---    \n**Parameters**  \n- _attributes_  \n    Attributes map  \n"
        }
      },
      "insertText": "setAttributes(${1:attributes});",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "typedesc",
      "kind": "Keyword",
      "detail": "Typedesc",
      "insertText": "typedesc",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "testConditionFunction()",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _._  \n  \n  \n  \n---    \n**Parameters**  \n"
        }
      },
      "insertText": "testConditionFunction();",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "elements()(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nGet all the items that are of element type in an XML sequence.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nxml"
        }
      },
      "insertText": "elements()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "unescape()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns an unescaped string by omitting the escape characters of the original string.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nstring"
        }
      },
      "insertText": "unescape()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "getElementName()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nGet the fully qualified name of the element as a string. Returns an empty string if the XML is not a singleton.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nstring"
        }
      },
      "insertText": "getElementName()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "toJSON($anonType$builtin$11 options)(json)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nConverts a XML object to a JSON representation.\n  \n  \n---    \n**Parameters**  \n- _options_  \n    xmlOptions struct for XML to JSON conversion properties  \n  \n  \n**Return**  \njson"
        }
      },
      "insertText": "toJSON(${1:options})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "getItemType()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nGet the type of a XML as a string. If the XML is singleton, type can be one of \u0027element\u0027, \u0027text\u0027, \u0027comment\u0027 or \u0027pi\u0027.\nReturns an empty string if the XML is not a singleton.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nstring"
        }
      },
      "insertText": "getItemType()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "float",
      "kind": "Keyword",
      "detail": "Float",
      "insertText": "float",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "remove(string key)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nRemoves each element that matches the given key.\n  \n  \n---    \n**Parameters**  \n- _key_  \n    Key of the field to remove  \n"
        }
      },
      "insertText": "remove(${1:key});",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "trim()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns a trimmed string by omitting the leading and trailing whitespaces of the original string.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nstring"
        }
      },
      "insertText": "trim()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "toString()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nConverts a JSON object to a string representation.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nstring"
        }
      },
      "insertText": "toString()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "strip()(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nStrips any text items from an XML sequence that are all whitespace.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nxml"
        }
      },
      "insertText": "strip()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "test",
      "kind": "Variable",
      "detail": "string|boolean",
      "insertText": "test",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "subscribe(function (any) returns () func)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nSubscribes to data from the stream.\n  \n  \n---    \n**Parameters**  \n- _func_  \n    The function pointer for the subscription, which will be invoked with data published to the stream  \n"
        }
      },
      "insertText": "subscribe(${1:func});",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "hasPrefix(string prefix)(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns a Boolean value indicating whether a string starts with the specified prefix.\n  \n  \n---    \n**Parameters**  \n- _prefix_  \n    The prefix to be compared  \n  \n  \n**Return**  \nboolean"
        }
      },
      "insertText": "hasPrefix(${1:prefix})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "keys()(string[])",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns an array of keys contained in the specified map.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nstring[]"
        }
      },
      "insertText": "keys()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "null",
      "kind": "Keyword",
      "detail": "Nil",
      "insertText": "null",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "hasNext()(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nChecks for a new row in the given table. If a new row is found, moves the cursor to it.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nboolean"
        }
      },
      "insertText": "hasNext()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "cancel()",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nCancels the given future.\n  \n  \n---    \n**Parameters**  \n"
        }
      },
      "insertText": "cancel();",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "decimal",
      "kind": "Keyword",
      "detail": "Decimal",
      "insertText": "decimal",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "matches(string regex)(boolean|error)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns a Boolean value indicating whether the string matches the regular expression.\n  \n  \n---    \n**Parameters**  \n- _regex_  \n    Regular expression  \n  \n  \n**Return**  \nboolean|error"
        }
      },
      "insertText": "matches(${1:regex})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "string",
      "kind": "Keyword",
      "detail": "String",
      "insertText": "string",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "error",
      "kind": "Keyword",
      "detail": "Error",
      "insertText": "error",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "contains(string substring)(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns a Boolean value indicating whether a string contains the specified substring.\n  \n  \n---    \n**Parameters**  \n- _substring_  \n    The substring to be compared  \n  \n  \n**Return**  \nboolean"
        }
      },
      "insertText": "contains(${1:substring})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "findAll(string regex)(string[]|error)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nFinds all the strings matching the regular expression.\n  \n  \n---    \n**Parameters**  \n- _regex_  \n    Regular expression  \n  \n  \n**Return**  \nstring[]|error"
        }
      },
      "insertText": "findAll(${1:regex})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "setChildren(xml children)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nSet the children of an XML if its a singleton. An Error otherwise. Any existing children will be removed.\n  \n  \n---    \n**Parameters**  \n- _children_  \n    children  \n"
        }
      },
      "insertText": "setChildren(${1:children});",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "removeChildren(string qname)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nRemove children matching the given name from an XML. This operation has no effect\nif the XML is not an element type XML.\n  \n  \n---    \n**Parameters**  \n- _qname_  \n    Namespace qualified name of the children to be removed  \n"
        }
      },
      "insertText": "removeChildren(${1:qname});",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "json",
      "kind": "Keyword",
      "detail": "Json",
      "insertText": "json",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "length()(int)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns the length of the specified string.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nint"
        }
      },
      "insertText": "length()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "toXML($anonType$builtin$0 options)(xml|error)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nConverts a JSON object to a XML representation.\n  \n  \n---    \n**Parameters**  \n- _options_  \n    jsonOptions struct for JSON to XML conversion properties  \n  \n  \n**Return**  \nxml|error"
        }
      },
      "insertText": "toXML(${1:options})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "removeAttribute(string qname)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nRemove an attribute from an XML.\n  \n  \n---    \n**Parameters**  \n- _qname_  \n    Qualified name of the attribute  \n"
        }
      },
      "insertText": "removeAttribute(${1:qname});",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "slice(int startIndex, int endIndex)(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nSlice and return a subsequence of the an XML sequence.\n  \n  \n---    \n**Parameters**  \n- _startIndex_  \n    Start index, inclusive  \n  \n- _endIndex_  \n    End index, exclusive  \n  \n  \n**Return**  \nxml"
        }
      },
      "insertText": "slice(${1:startIndex}, ${2:endIndex})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "getKeys()(string[])",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns an array of keys contained in the specified JSON.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nstring[]"
        }
      },
      "insertText": "getKeys()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "add(any data)(error?)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nAdd record to the table.\n  \n  \n---    \n**Parameters**  \n- _data_  \n    A record with data  \n  \n  \n**Return**  \nerror?"
        }
      },
      "insertText": "add(${1:data})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "selectDescendants(string qname)(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nSearches in children recursively for elements matching the qualified name and returns a sequence containing them\nall. Does not search within a matched result.\n  \n  \n---    \n**Parameters**  \n- _qname_  \n    Qualified name of the element  \n  \n  \n**Return**  \nxml"
        }
      },
      "insertText": "selectDescendants(${1:qname})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "any",
      "kind": "Keyword",
      "detail": "Any",
      "insertText": "any",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "int",
      "kind": "Keyword",
      "detail": "Int",
      "insertText": "int",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "ObjectName",
      "kind": "Class",
      "detail": "Object",
      "insertText": "ObjectName",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "lastIndexOf(string substring)(int)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns the first index of the last occurence of the substring within the specified string.\n  \n  \n---    \n**Parameters**  \n- _substring_  \n    The substring to search for  \n  \n  \n**Return**  \nint"
        }
      },
      "insertText": "lastIndexOf(${1:substring})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "boolean",
      "kind": "Keyword",
      "detail": "Boolean",
      "insertText": "boolean",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "getTextValue()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nGet the text value of a XML. If the XML is a sequence, concatenation of the text values of the members of the\nsequence is returned. If the XML is an element, then the text value of the sequence of children is returned. If\nthe XML is a text item, then the text is returned. Otherwise, an empty string is returned.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nstring"
        }
      },
      "insertText": "getTextValue()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "service",
      "kind": "Keyword",
      "detail": "Service",
      "insertText": "service",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "appendChildren(xml children)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nAppend children to an XML if its an element type XML. Error otherwise.\nNew children will be appended at the end of the existing children.\n  \n  \n---    \n**Parameters**  \n- _children_  \n    children  \n"
        }
      },
      "insertText": "appendChildren(${1:children});",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "toLower()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nReturns a string with all the characters converted to lowercase.\n  \n  \n---    \n**Parameters**  \n  \n  \n**Return**  \nstring"
        }
      },
      "insertText": "toLower()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "toByteArray(string encoding)(byte[])",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/builtin_  \n  \nConverts string to a byte array.\n  \n  \n---    \n**Parameters**  \n- _encoding_  \n    Encoding to be used in the conversion  \n  \n  \n**Return**  \nbyte[]"
        }
      },
      "insertText": "toByteArray(${1:encoding})",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "ballerina/http",
      "kind": "Module",
      "detail": "Package",
      "insertText": "http",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "ballerina/jwt",
      "kind": "Module",
      "detail": "Package",
      "insertText": "jwt",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/jwt;\n"
        }
      ]
    },
    {
      "label": "ballerina/crypto",
      "kind": "Module",
      "detail": "Package",
      "insertText": "crypto",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/crypto;\n"
        }
      ]
    },
    {
      "label": "ballerina/h2",
      "kind": "Module",
      "detail": "Package",
      "insertText": "h2",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/h2;\n"
        }
      ]
    },
    {
      "label": "ballerina/privacy",
      "kind": "Module",
      "detail": "Package",
      "insertText": "privacy",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/privacy;\n"
        }
      ]
    },
    {
      "label": "ballerina/cache",
      "kind": "Module",
      "detail": "Package",
      "insertText": "cache",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/cache;\n"
        }
      ]
    },
    {
      "label": "ballerina/test",
      "kind": "Module",
      "detail": "Package",
      "insertText": "test",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/test;\n"
        }
      ]
    },
    {
      "label": "ballerina/file",
      "kind": "Module",
      "detail": "Package",
      "insertText": "file",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/file;\n"
        }
      ]
    },
    {
      "label": "ballerina/grpc",
      "kind": "Module",
      "detail": "Package",
      "insertText": "grpc",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/grpc;\n"
        }
      ]
    },
    {
      "label": "ballerina/config",
      "kind": "Module",
      "detail": "Package",
      "insertText": "config",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/config;\n"
        }
      ]
    },
    {
      "label": "ballerina/auth",
      "kind": "Module",
      "detail": "Package",
      "insertText": "auth",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/auth;\n"
        }
      ]
    },
    {
      "label": "ballerina/filepath",
      "kind": "Module",
      "detail": "Package",
      "insertText": "filepath",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/filepath;\n"
        }
      ]
    },
    {
      "label": "ballerina/ldap",
      "kind": "Module",
      "detail": "Package",
      "insertText": "ldap",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/ldap;\n"
        }
      ]
    },
    {
      "label": "ballerina/streams",
      "kind": "Module",
      "detail": "Package",
      "insertText": "streams",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/streams;\n"
        }
      ]
    },
    {
      "label": "ballerina/artemis",
      "kind": "Module",
      "detail": "Package",
      "insertText": "artemis",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/artemis;\n"
        }
      ]
    },
    {
      "label": "ballerina/reflect",
      "kind": "Module",
      "detail": "Package",
      "insertText": "reflect",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/reflect;\n"
        }
      ]
    },
    {
      "label": "ballerina/io",
      "kind": "Module",
      "detail": "Package",
      "insertText": "io",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "ballerina/runtime",
      "kind": "Module",
      "detail": "Package",
      "insertText": "runtime",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/runtime;\n"
        }
      ]
    },
    {
      "label": "ballerina/oauth2",
      "kind": "Module",
      "detail": "Package",
      "insertText": "oauth2",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/oauth2;\n"
        }
      ]
    },
    {
      "label": "ballerina/internal",
      "kind": "Module",
      "detail": "Package",
      "insertText": "internal",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/internal;\n"
        }
      ]
    },
    {
      "label": "ballerina/jvm",
      "kind": "Module",
      "detail": "Package",
      "insertText": "jvm",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/jvm;\n"
        }
      ]
    },
    {
      "label": "ballerina/encoding",
      "kind": "Module",
      "detail": "Package",
      "insertText": "encoding",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/encoding;\n"
        }
      ]
    },
    {
      "label": "ballerina/utils",
      "kind": "Module",
      "detail": "Package",
      "insertText": "utils",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/utils;\n"
        }
      ]
    },
    {
      "label": "ballerina/rabbitmq",
      "kind": "Module",
      "detail": "Package",
      "insertText": "rabbitmq",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/rabbitmq;\n"
        }
      ]
    },
    {
      "label": "ballerina/openapi",
      "kind": "Module",
      "detail": "Package",
      "insertText": "openapi",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/openapi;\n"
        }
      ]
    },
    {
      "label": "ballerina/math",
      "kind": "Module",
      "detail": "Package",
      "insertText": "math",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/math;\n"
        }
      ]
    },
    {
      "label": "ballerina/time",
      "kind": "Module",
      "detail": "Package",
      "insertText": "time",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/time;\n"
        }
      ]
    },
    {
      "label": "ballerina/observe",
      "kind": "Module",
      "detail": "Package",
      "insertText": "observe",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/observe;\n"
        }
      ]
    },
    {
      "label": "ballerina/system",
      "kind": "Module",
      "detail": "Package",
      "insertText": "system",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/system;\n"
        }
      ]
    },
    {
      "label": "ballerina/transactions",
      "kind": "Module",
      "detail": "Package",
      "insertText": "transactions",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/transactions;\n"
        }
      ]
    },
    {
      "label": "ballerina/nats",
      "kind": "Module",
      "detail": "Package",
      "insertText": "nats",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/nats;\n"
        }
      ]
    },
    {
      "label": "ballerina/mysql",
      "kind": "Module",
      "detail": "Package",
      "insertText": "mysql",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/mysql;\n"
        }
      ]
    },
    {
      "label": "ballerina/task",
      "kind": "Module",
      "detail": "Package",
      "insertText": "task",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/task;\n"
        }
      ]
    },
    {
      "label": "ballerina/log",
      "kind": "Module",
      "detail": "Package",
      "insertText": "log",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/log;\n"
        }
      ]
    },
    {
      "label": "ballerina/mime",
      "kind": "Module",
      "detail": "Package",
      "insertText": "mime",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/mime;\n"
        }
      ]
    },
    {
      "label": "ballerina/jms",
      "kind": "Module",
      "detail": "Package",
      "insertText": "jms",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/jms;\n"
        }
      ]
    },
    {
      "label": "ballerina/socket",
      "kind": "Module",
      "detail": "Package",
      "insertText": "socket",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/socket;\n"
        }
      ]
    },
    {
      "label": "ballerina/sql",
      "kind": "Module",
      "detail": "Package",
      "insertText": "sql",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 1,
              "character": 0
            },
            "end": {
              "line": 1,
              "character": 0
            }
          },
          "newText": "import ballerina/sql;\n"
        }
      ]
    }
  ]
}