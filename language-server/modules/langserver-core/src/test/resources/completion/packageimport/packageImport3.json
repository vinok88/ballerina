{
  "position": {
    "line": 3,
    "character": 12
  },
  "source": "packageimport/source/module2/packageImport3.bal",
  "items": [
    {
      "label": "length(string str)(int)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nReturns the length of the string.\n  \n**Params**  \n- `string` str: the string  \n  \n**Returns** `int`   \n- the number of characters (code points) in `str`  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "length(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "iterator(string str)()",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nReturns an iterator over the string.\nThe iterator will yield the substrings of length 1 in order.\n  \n**Params**  \n- `string` str: the string to be iterated over  \n  \n**Returns** ``   \n- a new iterator object  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "iterator(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "concat(string... strs)(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nConcatenates zero or more strings.\n  \n**Params**  \n- strs: strings to be concatenated  \n  \n**Returns** `string`   \n- concatenation of all of the `strs`; empty string if `strs` is empty  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "concat(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "getCodePoint(string str, int index)(int)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nReturns the code point of a character in a string.\n  \n**Params**  \n- `string` str: the string  \n- `int` index: an index in `str`  \n  \n**Returns** `int`   \n- the Unicode code point of the character at `index` in `str`  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "getCodePoint(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "substring(string str, int startIndex, int endIndex)(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nReturns a substring of a string.\n  \n**Params**  \n- `string` str: source string.  \n- `int` startIndex: the starting index, inclusive  \n- `int` endIndex: the ending index, exclusive(Defaultable)  \n  \n**Returns** `string`   \n- substring consisting of characters with index >= startIndex and < endIndex  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "substring(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "codePointCompare(string str1, string str2)(int)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nLexicographically compares strings using their Unicode code points.\nThis orders strings in a consistent and well-defined way,\nbut the ordering will often not be consistent with cultural expectations\nfor sorted order.\n  \n**Params**  \n- `string` str1: the first string to be compared  \n- `string` str2: the second string to be compared  \n  \n**Returns** `int`   \n- an int that is less than, equal to or greater than zero,  \n   according as `str1` is less than, equal to or greater than `str2`  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "codePointCompare(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "join(string separator, string... strs)(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nJoins zero or more strings together with a separator.\n  \n**Params**  \n- `string` separator: separator string  \n- strs: strings to be joined  \n  \n**Returns** `string`   \n- a string consisting of all of `strs` concatenated in order  \n    with `separator` in between them  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "join(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "indexOf(string str, string substr, int startIndex)((int|()))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nSearches for one string in another string.\n  \n**Params**  \n- `string` str: the string in which to search  \n- `string` substr: the string to search for  \n- `int` startIndex: index to start searching from(Defaultable)  \n  \n**Returns** `(int|())`   \n- index of the first occurrence of `substr` in `str` that is >= `startIndex`,  \n   or `()` if there is no such occurrence  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "indexOf(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "startsWith(string str, string substr)(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nTests whether a string starts with another string.\n  \n**Params**  \n- `string` str: the string to be tested  \n- `string` substr: the starting string  \n  \n**Returns** `boolean`   \n- true if `str` starts with `substr`; false otherwise  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "startsWith(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "endsWith(string str, string substr)(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nTests whether a string ends with another string.\n  \n**Params**  \n- `string` str: the string to be tested  \n- `string` substr: the ending string  \n  \n**Returns** `boolean`   \n- true if `str` ends with `substr`; false otherwise  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "endsWith(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "toLowerAscii(string str)(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nConverts occurrences of A-Z to a-z.\nOther characters are left unchanged.\n  \n**Params**  \n- `string` str: the string to be converted  \n  \n**Returns** `string`   \n- `str` with any occurrences of A-Z converted to a-z  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "toLowerAscii(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "toUpperAscii(string str)(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nConverts occurrences of a-z to A-Z.\nOther characters are left unchanged.\n  \n**Params**  \n- `string` str: the string to be converted  \n  \n**Returns** `string`   \n- `str` with any occurrences of a-z converted to A-Z  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "toUpperAscii(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "trim(string str)(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nRemoves ASCII white space characters from the start and end of a string.\nThe ASCII white space characters are 0x9...0xD, 0x20.\n  \n**Params**  \n- `string` str: the string  \n  \n**Returns** `string`   \n- `str` with leading or trailing ASCII white space characters removed  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "trim(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "toBytes(string str)(byte[])",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nRepresents `str` as an array of bytes using UTF-8.\n  \n**Params**  \n- `string` str: the string  \n  \n**Returns** `byte[]`   \n- UTF-8 byte array  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "toBytes(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "fromBytes(byte[] bytes)((string|error))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nConstructs a string from its UTF-8 representation in `bytes`.\n  \n**Params**  \n- `byte[]` bytes: UTF-8 byte array  \n  \n**Returns** `(string|error)`   \n- `bytes` converted to string or error  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "fromBytes(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "toCodePointInts(string str)(int[])",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nConverts a string to an array of code points.\n  \n**Params**  \n- `string` str: the string  \n  \n**Returns** `int[]`   \n- an array with a code point for each character of `str`  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "toCodePointInts(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "fromCodePointInts(int[] codePoints)((string|error))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.string_  \n  \nConstructs a string from an array of code points.\nAn int is a valid code point if it is in the range 0 to 0x10FFFF inclusive,\nbut not in the range 0xD800 or 0xDFFF inclusive.\n  \n**Params**  \n- `int[]` codePoints: an array of ints, each specifying a code point  \n  \n**Returns** `(string|error)`   \n- a string with a character for each code point in `codePoints`; or an error  \nif any member of `codePoints` is not a valid code point  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "fromCodePointInts(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    }
  ]
}
